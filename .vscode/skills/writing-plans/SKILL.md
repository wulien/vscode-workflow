---
name: writing-plans
description: 当你有确认的需求/设计要拆分为实现任务时使用。在动手写代码之前。
---

# 编写实现计划 Skill

## 概述

将需求/设计文档转化为可执行的实现计划。假设执行者零上下文，每一步都必须足够详细——包含文件路径、完整代码、验证步骤。

## 核心原则

- **DRY** — 不要重复自己
- **YAGNI** — 不要构建不需要的东西
- **TDD** — 每个任务都是 测试→实现→验证
- **频繁提交** — 每完成一步就提交
- **小步快走** — 每个步骤 2-5 分钟

## 计划文档格式

### 文档头部

```markdown
# [功能名] 实现计划

**目标:** [一句话]
**架构:** [2-3 句话概述方案]
**技术栈:** [关键技术/库]

---
```

### 任务结构

每个任务包含：

```markdown
### Task N: [组件名]

**文件:**
- 创建: `exact/path/to/file.ts`
- 修改: `exact/path/to/existing.ts:行号范围`
- 测试: `tests/exact/path/to/test.ts`

**步骤 1: 编写失败的测试**

[完整的测试代码，不是"添加测试"]

**步骤 2: 运行测试确认失败**

运行: `npm test -- --grep "测试名"`
预期: FAIL — "function not defined"

**步骤 3: 编写最小实现**

[完整的实现代码]

**步骤 4: 运行测试确认通过**

运行: `npm test -- --grep "测试名"`
预期: PASS

**步骤 5: 提交**

git add <files>
git commit -m "feat: 具体描述"
```

## 任务粒度标准

**每步是一个动作（2-5 分钟）：**

- "编写失败的测试" — 一步
- "运行测试确认失败" — 一步
- "编写最小实现代码" — 一步
- "运行测试确认通过" — 一步
- "提交" — 一步

**不要：**
- "实现用户模块" — 太大
- "添加验证" — 太模糊

## 保存位置

```
docs/plans/YYYY-MM-DD-<feature-name>.md
```

## 完成后

提供两个执行选项：

1. **本会话执行** — 在当前对话中逐任务执行，每个任务执行后审查
2. **新会话执行** — 开一个新对话，按计划批量执行

## 记住

- 精确的文件路径
- 完整的代码（不是 "添加验证逻辑"）
- 精确的命令和预期输出
- 引用相关的 Skill
- DRY, YAGNI, TDD, 频繁提交
